#!/usr/bin/perl
use warnings;
use strict;

use Getopt::Long;
use Data::Dumper;

use File::Spec;
use File::Temp;
use File::Path qw/mkpath/;

use lib '.'; #only works when running dir is the same
use GenKode::MSA;
use GenKode::Commons;

#as of 2019-May-16
# tested on PAML version, 4.9f, Oct 2017
# tested result with one input tree only
# NOT tested on results from baseml yet

#-----------------------------------------------
# for extract PAML output file "rst", which contains ancestral sequence reconstruction (ASR) results.
# ASR can be turned on by writing "RateAccestor=1 (or 2)" in the control file


#this script will do the following in order:
# 1. extract the tree with node labels. map all nodes to taxa and clades
# 2. see below
# option1: give one full MSA "M1" with mask seq, input another MSA "M2" after only keeping mask regions, add missing regions from M1 back to M2.
# option2: give one full MSA "M3", and remove all sites with at least one gap to make "M4". add removed regions from M3 back to M4
#purpose: M2 and M4 may have chances, e.g. add additional seqs, add extra info (folding etc), but want to see the full alignment
# ONLY WORKS when the alignment isn't changed.



my ($help, $rstfile, $full_aln_gap_ref_file,$maskname);

GetOptions(
	'rstfile=s{1}'=>\$rstfile,
	'maskfile=s{1}'=>\$maskname,
	'fullalnfile=s{1}'=>\$full_aln_gap_ref_file,
	'help'=>\$help,
);


if ($help or !chkfile($rstfile)) { die <<USAGE;
-----------------------------------
# parse rst file from PAML (codeml/baseml) output
# will output to a rearranged alignment file, in order as in "rst"
# will extract the tree with labelled nodes

>>>> ALWAYS required for parsing rst file <<<<

[-r path_to_rst_file] this file must be the "rst" from output
  - generated by using "RateAccestor=1 (or 2)" in control file
  - NOT "rst1"
  - IMPORTANT: taxa names in the tree should NEVER contain space, or this script won't work

>>>> optional, for refill gaps of parsed rst-alignment to original alignment <<<<
# specify template file, refill missing regions to target file

# use one of the two below:
[-f path_to_full_aln] the full alignment with gaps (and/or mask)
[-g] use all no-gap columns for remap (default)
[-m mask_name] the exact mask name (case sensitive)
  - make sure mask name exists or it won't write anything
# as long as [-f] is given, [-g] is ALWAYS used unless [-m] being specified

# if PAML analysed the full alignment, no need to remap

-----------------------------------
USAGE
}

my @dirs=File::Spec->splitpath($rstfile);
pop @dirs;
my $ofiletree=File::Spec->catfile(@dirs, 'ASR_parse_tree_node_labels.newick.txt');
my $alnfile=File::Spec->catfile(@dirs, 'ASR_parse_aln_sort_by_node.fst');

print "\n\n";
print ">>input file:\n";
printf "  - %s\n", $rstfile;

# -------------- parse rst file
my $order;
my $namemap; #for write rst-aln
my $nodeseq;
{ # ----------- rst-parse-block-begin -------
my $treenum=0;
my $next;
my $alnblock;
my $alnblock_node;
open (my $fh, $rstfile);
while (<$fh>) {
	#process tree order, node mapping
	if (/^TREE \s+ \# \s+ (\d+)/x) {
		$treenum=$1;
	}
	elsif ($treenum) {
		if (/\d+\.\.\d+/) {
			$order=parse_node_order($_);
		}
		elsif (/tree with node labels/) {
			$next=1;
		}
		elsif ($next) {
			open (my $fht, ">", $ofiletree);
			print $fht $_;
			close ($fht);
			$namemap=parse_node_link($_);
			$next=0;
			$treenum=0; #the last thing needed for a tree block
		}
	}
	#process alignment sequence + reconstructed seq
	elsif (/List of extant and reconstructed sequences/i) {
		$alnblock=1;
	}
	elsif ($alnblock) {
		if (/^node \s+ \#(\d+)\s+(\S.+)$/ix) {
			my ($nodename,$seq2)=($1,$2);
			$seq2=~s/\s//g;
			$nodeseq->{node}{$nodename}=$seq2;
			$alnblock_node=1;
		}
		elsif (/^(\S+)\s+(\S.+)$/) {
			my ($name,$seq1)=($1,$2);
			$seq1=~s/\s//g;
			$nodeseq->{taxa}{$name}=$seq1;
		}
		elsif ($alnblock_node and /^\s*$/) {
			$alnblock=0;
			$alnblock_node=0;
			last; #got all seqs, end
		}
	}
}
} # ----------- rst-parse-block-end -------

my $namemap2; #for refill rst-aln to full-aln /// aln-name to ori-name
{ # ----------- write parsed RST-aln begin -------
open (my $fh2, ">", $alnfile);
foreach my $node (@$order) {
	my $sref;
	my $name;
	if ($namemap->{$node}) { #is a taxon
		$sref=$nodeseq->{taxa}{$namemap->{$node}};
		$name=sprintf 'node%d__%s', $node, $namemap->{$node};
		$namemap2->{$name}= $namemap->{$node};
	} else { #is a node
		$sref=$nodeseq->{node}{$node};
		$name=sprintf 'node%d', $node;
	}
	printf $fh2 ">%s\n%s\n", $name, $sref;
}
close ($fh2);
print ">>output files:\n";
printf "  - alignment: %s\n", $alnfile;
printf "  - tree: %s\n", $ofiletree;
} # ----------- write-rst-block-end -------


# ------------ refill rst-aln as full-aln , if specified -----
if (chkfile($alnfile) and chkfile($full_aln_gap_ref_file) ) {
	my $m_short=GenKode::MSA->new;
	$m_short->import($alnfile);

	my $col_in_short;
	my $m_full=GenKode::MSA->new;
	$m_full->import($full_aln_gap_ref_file);
	my $idmap=parse_id_map($namemap2,$m_short,$m_full);
	# ----- get positions without any gap/non-mask from tmplate-aln
	if ($maskname) {
		$col_in_short=get_cols_mask($m_full,$maskname);
	} else {
		$col_in_short=get_cols_nogap($m_full);
	}

	#--------------------- refill gaps--------------
	if ($col_in_short) {
		my $ofile=$alnfile.'_refilled.fst';
		open (my $fh2, ">", $ofile);
		if ($maskname) {
			foreach my $id (1..$m_full->lastid) {
				if ($m_full->getname($id) eq $maskname) {
					printf $fh2 ">%s\n%s\n",$m_full->getname($id),$m_full->getseq($id);
					last;
				}
			}
		}
		foreach my $id_short (1..$m_short->lastid) { #must print all seqs in input file = m_short
			my $n0=$m_short->getname($id_short);
			my $id_full=$idmap->{$n0}[1]||0;

			my $s2='';
			my $nogapcurr=0;
			foreach my $cm (0..($m_full->maxlen - 1)) { #longer, contain all sites
				if ($col_in_short->{$cm}) { #this site contain no gap , and should be proceed by paml. use paml's aln file (=input)
					$s2.=substr $m_short->getseq($id_short),$nogapcurr, 1;
					$nogapcurr++;
				}
				elsif ($id_full) { #this seq is in template file
					$s2.=substr $m_full->getseq($id_full),$cm, 1;
				}
				else { #this seq doesn't exist in full-aln file.
					$s2.='.'; #use dot to highlight seqs that do not exist in full-aln file
				}
			}
			printf $fh2 ">%s\n%s\n", $m_short->getname($id_short), $s2;
		}
		printf "  - alignment refilled: %s\n", $ofile;
	} else {
		print " !! can't refill gaps. possible reasons: all columns contain at least 1 gap; no specified mask found; aln contains mask but is treated as to extract no-gap; file do not exist";
	}
}

print "\n\n";



# ------ subs -----------
sub parse_node_link { #map node-num in rst to real taxon name
	my $tree=shift;
	my $taxa;
	my $nodes;
	while ($tree=~/\([^\)\(]+?\)\s*\d+/g) {
		my ($pre,$clade,$post)=($`,$&, $');
		my ($p0,$node)=$clade=~/\(  (  .+   ) \)  \s*  (\d+)/x;
		my @ts=split ',',$p0;
		foreach my $t1 (@ts) {
			if ($t1=~/^\s*\d+\s*$/) { #is already replaced by node number, do nothing
				next;
			} else {
				my ($taxon_node, $taxon)=$t1=~/^ \s* (\d+)_(\S+) /x;
				$taxa->{$taxon_node}=$taxon;
			}
		}
		$tree=$pre.$node.$post;
	}
	return $taxa;
}
sub parse_node_order {
	my @c=split /\s+/, shift;
	my $done;
	my $order;
	foreach my $raw (@c) {
		next if $raw !~/\.\./;
		my ($from, $to)=$raw=~/(\d+)\.\.(\d+)/;
		foreach my $x ($from, $to) {
			if (!$done->{$x}) {
				push @$order, $x;
				$done->{$x}=1;
			}
		}
	}
	return $order;
}

sub parse_id_map {
	# name-in-shortened-aln <tab> name-in-full-aln
	my ($namemap2,$m_short,$m_full)=@_;
	#namemap2 : aln-name to full-name
	my $m1;
	foreach my $aname (keys %$namemap2) {
		my $fname=$namemap2->{$aname};
		$m1->{$fname}=$aname; # n-full => n-short
	}

	my $map;
	foreach my $id1 (1..$m_short->lastid) {
		my $nshort=$m_short->getname($id1);
		$map->{$nshort}[0]=$id1;
	}
	foreach my $id2 (1..$m_full->lastid) {
		my $nfull=$m_full->getname($id2);
		my $nshort1=$m1->{$nfull}||$nfull; #so assuming seq-names are the same in both files
		$map->{$nshort1}[1]=$id2;
	}
	return $map;
}
sub get_cols_nogap {
	my $m_full=shift;
	my $nogapcols=$m_full->getnogapcols(0,1);
	my $keepcols;
	foreach my $j (@$nogapcols) {
		$keepcols->{$j}=1;
	}
	return $keepcols;
}
sub get_cols_mask {
	my ($m_full,$maskname)=@_;
	my $cols_array=$m_full->getmaskcols($maskname);
	my $cols;
	if ($cols_array) {
		foreach my $j (@$cols_array) {
			$cols->{$j}=1;
		}
	}
	return $cols;
}










__END__


# below, individual script for refill. probably won't use it individually so merged it here


#!/usr/bin/perl
use strict;
use warnings;
use File::Spec;
use File::Path;
use Getopt::Long;
use Data::Dumper;

use lib '.'; #only works when running dir is the same
use GenKode::MSA;

# option1: give one full MSA "M1" with mask seq, input another MSA "M2" after only keeping mask regions, add missing regions from M1 back to M2.
# option2: give one full MSA "M3", and remove all sites with at least one gap to make "M4". add removed regions from M3 back to M4
#purpose: M2 and M4 may have chances, e.g. add additional seqs, add extra info (folding etc), but want to see the full alignment
# ONLY WORKS when the alignment isn't changed.

my ($help, $alnfile, @full_aln_mask_ref_file, $full_aln_gap_ref_file,$idmapfile);

GetOptions(
	'alnfile=s{1}'=>\$alnfile,
	'idmapfile=s{1}'=>\$idmapfile,
	'maskfile=s{2}'=>\@full_aln_mask_ref_file,
	'gapfile=s{1}'=>\$full_aln_gap_ref_file,
	'help'=>\$help,
);


if ($help or !chkfile($alnfile) or (  !(chkfile($full_aln_gap_ref_file))  and !(chkfile($full_aln_mask_ref_file[0]))  )  ) {
	print <<USAGE;
-----------------------------------------------
#specify template file, refill missing regions to target file

required:
[-a path_to_aln_file] the file to be refilled with missing regions

optinoal:
[-p path_to_id_map_file] the file contain <TAB> separated chart. MUST specify if two alignments have the same seq but in different names
  format:
    name_in_aln_file <TAB> name_in_full_aln_file

use one of the two below:
[-g path_to_full_aln_with_gap] the full alignment with gaps
[-m path_to_full_aln_mask  mask_name] the full alignment with mask AND mask name (case sensitive)
* [-g] overwrites [-m] if both are given

-----------------------------------------------
	
USAGE
	exit;
}


my $ofile=$alnfile.'_refilled.fst';
open (my $fh2, ">", $ofile);

my $m_short=GenKode::MSA->new;
$m_short->import($alnfile);

my $col_in_short;
my $m_full=GenKode::MSA->new;
if (chkfile($full_aln_gap_ref_file)) { #block for process gap-based refill. override mask-based file if given
	$m_full->import($full_aln_gap_ref_file);
	$col_in_short=get_cols_nogap($m_full);
}
elsif (chkfile($full_aln_mask_ref_file[0])) {
	$m_full->import($full_aln_mask_ref_file[0]);
	$col_in_short=get_cols_mask($m_full,$full_aln_mask_ref_file[1]);
}

my $idmap=parse_id_map($idmapfile,$m_short,$m_full);

#get positions without any gap/non-mask from tmplate-aln




#--------------------- refill gaps--------------
if ($col_in_short) {
	if ($full_aln_mask_ref_file[1]) {
		foreach my $id (1..$m_full->lastid) {
			if ($m_full->getname($id) eq $full_aln_mask_ref_file[1]) {
				printf $fh2 ">%s\n%s\n",$m_full->getname($id),$m_full->getseq($id);
				last;
			}
		}
	}
	foreach my $id_short (1..$m_short->lastid) { #must print all seqs in input file = m_short
		my $n0=$m_short->getname($id_short);
		my $id_full=$idmap->{$n0}[1]||0;

		my $s2='';
		my $nogapcurr=0;
		foreach my $cm (0..($m_full->maxlen - 1)) { #longer, contain all sites
			if ($col_in_short->{$cm}) { #this site contain no gap , and should be proceed by paml. use paml's aln file (=input)
				$s2.=substr $m_short->getseq($id_short),$nogapcurr, 1;
				$nogapcurr++;
			}
			elsif ($id_full) { #this seq is in template file
				$s2.=substr $m_full->getseq($id_full),$cm, 1;
			}
			else { #this seq doesn't exist in full-aln file.
				$s2.='.'; #use dot to highlight seqs that do not exist in full-aln file
			}
		}
		printf $fh2 ">%s\n%s\n", $m_short->getname($id_short), $s2;
	}
} else {
	print "can't refill gaps. possible reasons: all columns contain at least 1 gap; no specified mask found, file do not exist";
}

# --------- subs --------
sub parse_id_map {
	# name-in-shortened-aln <tab> name-in-full-aln
	my ($idmapfile,$m_short,$m_full)=@_;
	my $m1;
	my $m2;
	if (open (my $fh, $idmapfile) ) {
		while (<$fh>) {
			next if /^#/;
			chomp;
			my (@c)=split /\t/;
			if (!$c[0] or !$c[1]) {
				next;
			}
			$m1->{$c[1]}=$c[0]; # n-full => n-short
			$m2->{$c[0]}=$c[1];
		}
	}

	my $map;
	foreach my $id1 (1..$m_short->lastid) {
		my $nshort=$m_short->getname($id1);
		$map->{$nshort}[0]=$id1;
	}
	foreach my $id2 (1..$m_full->lastid) {
		my $nfull=$m_full->getname($id2);
		my $nshort1=$m1->{$nfull}||$nfull; #so assuming seq-names are the same in both files
		$map->{$nshort1}[1]=$id2;
	}
	return $map;
}
sub get_cols_nogap {
	my $m_full=shift;
	my $keepcols;
	for my $cm (0..($m_full->maxlen - 1)) {
		my $hasgap;
		foreach my $id (1..$m_full->lastid) {
			my $c=substr $m_full->getseq($id), $cm, 1;
			if ($c!~/\w/ or $c=~/x/i) { #is a gap . also, PAML treats X as gap too
				$hasgap=1;
				last;
			}
		}
		if (!$hasgap) {
			$keepcols->{$cm}=1;
		}
	}
	return $keepcols;
}
sub get_cols_mask {
	my ($m_full,$mask)=@_;
	my $cols;
	$mask='' if !$mask;
	foreach my $id (1..$m_full->lastid) {
		if ($m_full->getname($id) eq $mask) {
			my $ref=$m_full->getseq($id);
			for my $j (0..((length $ref)-1)) {
				my $c=substr $ref, $j, 1;
				if ($c=~/\w/) {
					$cols->{$j}=1;
				}
			}
			last;
		}
	}
	return $cols;
}

sub chkfile {
	my $file=shift;
	if (!$file or !-e $file or -z $file) {
		return 0;
	} else {
		return 1;
	}
}
